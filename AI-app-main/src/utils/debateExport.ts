/**
 * Debate Export Utilities
 *
 * Generate debate transcripts in HTML, Markdown, and JSON formats.
 * Allows users to save and share debate sessions.
 */

import type {
  DebateSession,
  DebateMessage,
  DebateConsensus,
  DebateCost,
} from "@/types/aiCollaboration";
import { getRoleDisplayName, MODEL_DISPLAY_INFO } from "@/prompts/debatePersonas";

// ============================================================================
// TYPES
// ============================================================================

export type DebateExportFormat = "html" | "markdown" | "json";

export interface DebateExportConfig {
  includeTimestamps?: boolean;
  includeTokenCounts?: boolean;
  includeCostBreakdown?: boolean;
  includeMetadata?: boolean;
}

const DEFAULT_CONFIG: DebateExportConfig = {
  includeTimestamps: true,
  includeTokenCounts: false,
  includeCostBreakdown: true,
  includeMetadata: true,
};

// ============================================================================
// MARKDOWN EXPORT
// ============================================================================

/**
 * Export debate session as Markdown
 */
export function exportDebateAsMarkdown(
  session: DebateSession,
  config: DebateExportConfig = DEFAULT_CONFIG
): string {
  const lines: string[] = [];

  // Header
  lines.push(`# AI Debate: ${session.userQuestion}`);
  lines.push("");

  // Metadata
  if (config.includeMetadata) {
    lines.push(`**Date:** ${formatDate(session.createdAt)}`);
    lines.push(`**Status:** ${formatStatus(session.status)}`);
    lines.push(`**Style:** ${formatStyle(session.style)}`);
    lines.push(
      `**Participants:** ${session.participants
        .map((p) => `${p.displayName} (${getRoleDisplayName(p.role)})`)
        .join(", ")}`
    );
    lines.push(`**Rounds:** ${session.roundCount}/${session.maxRounds}`);
    lines.push("");
  }

  // Cost summary
  if (config.includeCostBreakdown && session.cost) {
    lines.push("## Cost Summary");
    lines.push("");
    lines.push(`- **Total Cost:** $${session.cost.totalCost.toFixed(4)}`);
    lines.push(
      `- **Total Tokens:** ${(
        session.cost.totalInputTokens + session.cost.totalOutputTokens
      ).toLocaleString()}`
    );
    lines.push("");

    // Per-model breakdown
    Object.entries(session.cost.byModel).forEach(([modelId, data]) => {
      const modelInfo = MODEL_DISPLAY_INFO[modelId as keyof typeof MODEL_DISPLAY_INFO];
      lines.push(
        `  - ${modelInfo?.displayName || modelId}: $${data.cost.toFixed(4)} (${data.inputTokens + data.outputTokens} tokens)`
      );
    });
    lines.push("");
  }

  // Discussion
  lines.push("---");
  lines.push("");
  lines.push("## Discussion");
  lines.push("");

  session.messages.forEach((msg, index) => {
    const modelInfo = MODEL_DISPLAY_INFO[msg.modelId as keyof typeof MODEL_DISPLAY_INFO];
    const roleDisplay = getRoleDisplayName(msg.role);

    // Message header
    lines.push(
      `### ${modelInfo?.displayName || msg.modelDisplayName} (${roleDisplay})`
    );

    // Timestamp
    if (config.includeTimestamps) {
      lines.push(`*${formatTime(msg.timestamp)}*`);
    }

    // Agreement indicator
    if (msg.isAgreement) {
      lines.push("");
      lines.push("> ü§ù **Agreement expressed**");
    }

    lines.push("");
    lines.push(msg.content);
    lines.push("");

    // Token count
    if (config.includeTokenCounts) {
      lines.push(
        `*Tokens: ${msg.tokensUsed.input} in / ${msg.tokensUsed.output} out*`
      );
      lines.push("");
    }

    // Separator
    if (index < session.messages.length - 1) {
      lines.push("---");
      lines.push("");
    }
  });

  // Consensus
  if (session.consensus) {
    lines.push("---");
    lines.push("");
    lines.push("## Consensus");
    lines.push("");
    lines.push(session.consensus.summary);
    lines.push("");

    // Key decisions
    if (session.consensus.keyDecisions.length > 0) {
      lines.push("### Key Decisions");
      lines.push("");
      session.consensus.keyDecisions.forEach((decision) => {
        lines.push(`- ${decision}`);
      });
      lines.push("");
    }

    // Action items
    if (session.consensus.actionItems.length > 0) {
      lines.push("### Action Items");
      lines.push("");
      session.consensus.actionItems.forEach((item) => {
        const priority =
          item.priority === "high"
            ? "üî¥"
            : item.priority === "medium"
            ? "üü°"
            : "üü¢";
        lines.push(`- ${priority} **${item.priority.toUpperCase()}**: ${item.description}`);
      });
      lines.push("");
    }
  }

  // Footer
  lines.push("---");
  lines.push("");
  lines.push(
    `*Generated by AI Debate System on ${formatDate(new Date().toISOString())}*`
  );

  return lines.join("\n");
}

// ============================================================================
// HTML EXPORT
// ============================================================================

/**
 * Export debate session as styled HTML
 */
export function exportDebateAsHTML(
  session: DebateSession,
  config: DebateExportConfig = DEFAULT_CONFIG
): string {
  const modelColors: Record<string, { bg: string; text: string }> = {
    "claude-opus-4": { bg: "#8B5CF6", text: "#F3E8FF" },
    "claude-sonnet-4": { bg: "#A78BFA", text: "#F3E8FF" },
    "gpt-5": { bg: "#10B981", text: "#D1FAE5" },
    "gpt-4o": { bg: "#34D399", text: "#D1FAE5" },
    "gemini-pro": { bg: "#3B82F6", text: "#DBEAFE" },
    "gemini-ultra": { bg: "#60A5FA", text: "#DBEAFE" },
  };

  let html = `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AI Debate: ${escapeHtml(session.userQuestion)}</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Inter', system-ui, sans-serif;
      background: #0F172A;
      color: #F8FAFC;
      line-height: 1.6;
      padding: 2rem;
    }
    .container { max-width: 800px; margin: 0 auto; }
    h1 { font-size: 1.75rem; font-weight: 700; margin-bottom: 0.5rem; }
    h2 { font-size: 1.25rem; font-weight: 600; margin: 2rem 0 1rem; color: #94A3B8; }
    .meta { display: flex; flex-wrap: wrap; gap: 1rem; margin-bottom: 2rem; font-size: 0.875rem; color: #64748B; }
    .meta-item { display: flex; align-items: center; gap: 0.5rem; }
    .badge {
      display: inline-flex; align-items: center; gap: 0.5rem;
      padding: 0.25rem 0.75rem; border-radius: 9999px;
      font-size: 0.75rem; font-weight: 500;
    }
    .message {
      background: #1E293B; border-radius: 0.75rem; padding: 1.5rem;
      margin-bottom: 1rem; border-left: 4px solid;
    }
    .message-header { display: flex; align-items: center; gap: 0.75rem; margin-bottom: 0.75rem; }
    .message-name { font-weight: 600; }
    .message-role { font-size: 0.75rem; color: #64748B; }
    .message-time { font-size: 0.75rem; color: #475569; margin-left: auto; }
    .message-content { white-space: pre-wrap; color: #E2E8F0; }
    .agreement-badge {
      display: inline-flex; align-items: center; gap: 0.25rem;
      background: rgba(16, 185, 129, 0.2); color: #10B981;
      padding: 0.25rem 0.5rem; border-radius: 0.25rem;
      font-size: 0.75rem; font-weight: 500;
    }
    .consensus {
      background: linear-gradient(135deg, rgba(139, 92, 246, 0.1), rgba(16, 185, 129, 0.1));
      border: 1px solid rgba(139, 92, 246, 0.3);
      border-radius: 0.75rem; padding: 1.5rem; margin-top: 2rem;
    }
    .consensus h2 { margin-top: 0; color: #F8FAFC; }
    .action-item {
      display: flex; align-items: flex-start; gap: 0.5rem;
      padding: 0.75rem; background: #0F172A; border-radius: 0.5rem; margin-bottom: 0.5rem;
    }
    .priority-high { color: #EF4444; }
    .priority-medium { color: #F59E0B; }
    .priority-low { color: #22C55E; }
    .footer { margin-top: 2rem; padding-top: 1rem; border-top: 1px solid #334155; font-size: 0.75rem; color: #64748B; }
  </style>
</head>
<body>
  <div class="container">
    <h1>${escapeHtml(session.userQuestion)}</h1>

    <div class="meta">
      <div class="meta-item">üìÖ ${formatDate(session.createdAt)}</div>
      <div class="meta-item">üìä ${formatStatus(session.status)}</div>
      <div class="meta-item">üîÑ ${session.roundCount} rounds</div>
      ${
        config.includeCostBreakdown && session.cost
          ? `<div class="meta-item">üí∞ $${session.cost.totalCost.toFixed(4)}</div>`
          : ""
      }
    </div>

    <h2>Participants</h2>
    <div style="display: flex; gap: 1rem; flex-wrap: wrap; margin-bottom: 2rem;">
      ${session.participants
        .map((p) => {
          const colors = modelColors[p.modelId] || { bg: "#6B7280", text: "#F9FAFB" };
          return `<span class="badge" style="background: ${colors.bg}20; color: ${colors.bg}; border: 1px solid ${colors.bg}40;">
            ${p.displayName} ¬∑ ${getRoleDisplayName(p.role)}
          </span>`;
        })
        .join("")}
    </div>

    <h2>Discussion</h2>
    ${session.messages
      .map((msg) => {
        const colors = modelColors[msg.modelId] || { bg: "#6B7280", text: "#F9FAFB" };
        return `
        <div class="message" style="border-left-color: ${colors.bg};">
          <div class="message-header">
            <span class="message-name" style="color: ${colors.bg};">${escapeHtml(msg.modelDisplayName)}</span>
            <span class="message-role">${getRoleDisplayName(msg.role)}</span>
            ${msg.isAgreement ? '<span class="agreement-badge">ü§ù Agreement</span>' : ""}
            ${config.includeTimestamps ? `<span class="message-time">${formatTime(msg.timestamp)}</span>` : ""}
          </div>
          <div class="message-content">${escapeHtml(msg.content)}</div>
        </div>`;
      })
      .join("")}

    ${
      session.consensus
        ? `
    <div class="consensus">
      <h2>üéØ Consensus</h2>
      <p style="margin: 1rem 0; color: #E2E8F0;">${escapeHtml(session.consensus.summary)}</p>

      ${
        session.consensus.keyDecisions.length > 0
          ? `
      <h3 style="font-size: 0.875rem; color: #94A3B8; margin: 1rem 0 0.5rem;">Key Decisions</h3>
      <ul style="list-style: none; color: #E2E8F0;">
        ${session.consensus.keyDecisions.map((d) => `<li>‚úì ${escapeHtml(d)}</li>`).join("")}
      </ul>`
          : ""
      }

      ${
        session.consensus.actionItems.length > 0
          ? `
      <h3 style="font-size: 0.875rem; color: #94A3B8; margin: 1rem 0 0.5rem;">Action Items</h3>
      ${session.consensus.actionItems
        .map(
          (item) => `
        <div class="action-item">
          <span class="priority-${item.priority}">‚óè</span>
          <span>${escapeHtml(item.description)}</span>
        </div>`
        )
        .join("")}`
          : ""
      }
    </div>`
        : ""
    }

    <div class="footer">
      Generated by AI Debate System on ${formatDate(new Date().toISOString())}
    </div>
  </div>
</body>
</html>`;

  return html;
}

// ============================================================================
// JSON EXPORT
// ============================================================================

/**
 * Export debate session as JSON
 */
export function exportDebateAsJSON(session: DebateSession): string {
  return JSON.stringify(session, null, 2);
}

// ============================================================================
// DOWNLOAD HELPERS
// ============================================================================

/**
 * Download debate as file
 */
export function downloadDebate(
  session: DebateSession,
  format: DebateExportFormat,
  config?: DebateExportConfig
): void {
  let content: string;
  let mimeType: string;
  let extension: string;

  switch (format) {
    case "markdown":
      content = exportDebateAsMarkdown(session, config);
      mimeType = "text/markdown";
      extension = "md";
      break;
    case "html":
      content = exportDebateAsHTML(session, config);
      mimeType = "text/html";
      extension = "html";
      break;
    case "json":
      content = exportDebateAsJSON(session);
      mimeType = "application/json";
      extension = "json";
      break;
  }

  // Create filename
  const sanitizedQuestion = session.userQuestion
    .slice(0, 50)
    .replace(/[^a-zA-Z0-9]/g, "_");
  const filename = `debate_${sanitizedQuestion}_${formatDateForFilename(session.createdAt)}.${extension}`;

  // Create blob and download
  const blob = new Blob([content], { type: mimeType });
  const url = URL.createObjectURL(blob);
  const link = document.createElement("a");
  link.href = url;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}

/**
 * Copy debate to clipboard
 */
export async function copyDebateToClipboard(
  session: DebateSession,
  format: "markdown" | "json" = "markdown",
  config?: DebateExportConfig
): Promise<void> {
  const content =
    format === "markdown"
      ? exportDebateAsMarkdown(session, config)
      : exportDebateAsJSON(session);

  await navigator.clipboard.writeText(content);
}

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

function formatDate(isoString: string): string {
  return new Date(isoString).toLocaleDateString("en-US", {
    year: "numeric",
    month: "long",
    day: "numeric",
  });
}

function formatTime(isoString: string): string {
  return new Date(isoString).toLocaleTimeString("en-US", {
    hour: "2-digit",
    minute: "2-digit",
  });
}

function formatDateForFilename(isoString: string): string {
  return new Date(isoString).toISOString().split("T")[0];
}

function formatStatus(status: string): string {
  const statusMap: Record<string, string> = {
    starting: "Starting",
    debating: "In Progress",
    agreed: "Consensus Reached",
    "user-ended": "Ended by User",
    error: "Error",
  };
  return statusMap[status] || status;
}

function formatStyle(style: string): string {
  const styleMap: Record<string, string> = {
    cooperative: "Cooperative",
    adversarial: "Adversarial",
    red_team: "Red Team",
    panel: "Panel Discussion",
  };
  return styleMap[style] || style;
}

function escapeHtml(text: string): string {
  const div = typeof document !== "undefined" ? document.createElement("div") : null;
  if (div) {
    div.textContent = text;
    return div.innerHTML;
  }
  // Fallback for server-side
  return text
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#039;");
}
